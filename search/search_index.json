{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java Pulsar client.\nIt is published for Scala 2.13. You can include it in your project by adding the following dependencies.\nsbt libraryDependencies ++= Seq(\n  \"com.chatroulette\" %% \"neutron-core\" % \"0.0.6\",\n  \"com.chatroulette\" %% \"neutron-circe\" % \"0.0.6\",\n  \"com.chatroulette\" %% \"neutron-function\" % \"0.0.6\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-core_2.13</artifactId>\n    <version>0.0.6</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-circe_2.13</artifactId>\n    <version>0.0.6</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-function_2.13</artifactId>\n    <version>0.0.6</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.chatroulette:neutron-core_2.13:0.0.6\"\n  implementation \"com.chatroulette:neutron-circe_2.13:0.0.6\"\n  implementation \"com.chatroulette:neutron-function_2.13:0.0.6\"\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Here’s a quick consumer / producer example using Neutron. Note: both are fully asynchronous.\nimport scala.concurrent.duration._\n\nimport cats.effect._\nimport cats.implicits._\nimport fs2.Stream\n\nimport cr.pulsar._\nimport cr.pulsar.schema.utf8._\n\nobject Demo extends IOApp {\n\n  val config = Config.Builder.default\n\n  val topic  =\n    Topic.Builder\n      .withName(\"my-topic\")\n      .withConfig(config)\n      .withType(Topic.Type.NonPersistent)\n      .build\n\n  val subs =\n    Subscription.Builder\n      .withName(\"my-sub\")\n      .withType(Subscription.Type.Shared)\n      .build\n\n  val resources: Resource[IO, (Consumer[IO, String], Producer[IO, String])] =\n    for {\n      pulsar   <- Pulsar.make[IO](config.url)\n      consumer <- Consumer.make[IO, String](pulsar, topic, subs)\n      producer <- Producer.make[IO, String](pulsar, topic)\n    } yield (consumer, producer)\n\n  def run(args: List[String]): IO[ExitCode] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .subscribe\n              .evalMap(m => IO(println(m.payload)) >> consumer.ack(m.id))\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_(_))\n\n          consume.concurrently(produce)\n      }.compile.drain.as(ExitCode.Success)\n\n}","title":"Quick start"},{"location":"/index.html#schema","text":"As of version 0.0.6, Neutron ships with support for Pulsar Schema. The simplest way to get started is to use the given UTF-8 encoding, which makes use of the native Schema.BYTES.\nimport cr.pulsar.schema.utf8._\nThis brings into scope an Schema[String] instance, required to initialize consumers and producers. There’s also a default instance Schema[A], for any cats.Inject[A, Array[Byte]] instance (based on Schema.BYTES as well).\nAt Chatroulette, we use JSON-serialised data for which we derive a Schema.JSON based on Circe codecs. Those interested in doing the same can leverage the Circe integration by adding the neutron-circe dependency.\nOnce you have it, you are an import away from having JSON schema support.\nimport cr.pulsar.schema.Schema\nimport cr.pulsar.schema.circe._\n\nimport io.circe.{Decoder, Encoder}\nimport io.circe.generic.semiauto._\n\ncase class Event(id: Long, name: String)\nobject Event {\n  implicit val jsonEncoder: Encoder[Event] = deriveEncoder\n  implicit val jsonDecoder: Decoder[Event] = deriveDecoder\n}\n\nval schema = Schema[Event] // summon an instance\nBe aware that your datatype needs to provide instances of io.circe.Encoder and io.circe.Decoder for this instance to become available.","title":"Schema"},{"location":"/index.html#schema-compatibility-check-strategy","text":"Whenever using schemas, make sure you fully understand the different strategies, which only operate at the namespace level (e.g. see how integration tests are set up in the run.sh shell script).\nFor instance, when using the BACKWARD mode, a producer and consumer will fail to initialize if the schemas are incompatible, even if your custom JSON decoder can deserialize the previous model, the Pulsar broker doesn’t know about it. E.g. say we have this model in our new application.\ncase class Event(uuid: UUID, value: String)\nAnd later on, we introduce a breaking change in the model, adding a new mandatory field.\ncase class Event(uuid: UUID, value: String, code: Int)\nThis will be rejected at runtime, validated by Pulsar Schemas, when using the BACKWARD mode. The only changes allowed in this mode are:\nAdd optional fields Delete fields\nInstead, we should make the new field optional for this to work.\ncase class Event(uuid: UUID, value: String, code: Option[Int])\nThis is now accepted by Pulsar since any previous Event still not consumed from a Pulsar topic can still be processed by the new consumers expecting the new schema.","title":"Schema Compatibility Check Strategy"}]}