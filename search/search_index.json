{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java Pulsar client.\nIt is published for Scala 2.13. You can include it in your project by adding the following dependencies.\nsbt libraryDependencies ++= Seq(\n  \"com.chatroulette\" %% \"neutron-core\" % \"0.0.7\",\n  \"com.chatroulette\" %% \"neutron-circe\" % \"0.0.7\",\n  \"com.chatroulette\" %% \"neutron-function\" % \"0.0.7\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-core_2.13</artifactId>\n    <version>0.0.7</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-circe_2.13</artifactId>\n    <version>0.0.7</version>\n  </dependency>\n  <dependency>\n    <groupId>com.chatroulette</groupId>\n    <artifactId>neutron-function_2.13</artifactId>\n    <version>0.0.7</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.chatroulette:neutron-core_2.13:0.0.7\"\n  implementation \"com.chatroulette:neutron-circe_2.13:0.0.7\"\n  implementation \"com.chatroulette:neutron-function_2.13:0.0.7\"\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Here’s a quick consumer / producer example using Neutron. Note: both are fully asynchronous.\nimport scala.concurrent.duration._\n\nimport cats.effect._\nimport cats.implicits._\nimport fs2.Stream\n\nimport cr.pulsar._\nimport cr.pulsar.schema.utf8._\n\nobject Demo extends IOApp {\n\n  val config = Config.Builder.default\n\n  val topic  =\n    Topic.Builder\n      .withName(\"my-topic\")\n      .withConfig(config)\n      .withType(Topic.Type.NonPersistent)\n      .build\n\n  val subs =\n    Subscription.Builder\n      .withName(\"my-sub\")\n      .withType(Subscription.Type.Shared)\n      .build\n\n  val resources: Resource[IO, (Consumer[IO, String], Producer[IO, String])] =\n    for {\n      pulsar   <- Pulsar.make[IO](config.url)\n      consumer <- Consumer.make[IO, String](pulsar, topic, subs)\n      producer <- Producer.make[IO, String](pulsar, topic)\n    } yield (consumer, producer)\n\n  def run(args: List[String]): IO[ExitCode] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .subscribe\n              .evalMap(m => IO(println(m.payload)) >> consumer.ack(m.id))\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_(_))\n\n          consume.concurrently(produce)\n      }.compile.drain.as(ExitCode.Success)\n\n}","title":"Quick start"},{"location":"/index.html#schema","text":"As of version 0.0.6, Neutron ships with support for Pulsar Schema. The simplest way to get started is to use the given UTF-8 encoding, which makes use of the native Schema.BYTES.\nimport cr.pulsar.schema.Schema\nimport cr.pulsar.schema.utf8._\n\nval schema = Schema[String] // summon instance\nThis brings into scope an Schema[String] instance, required to initialize consumers and producers. There’s also a default instance Schema[A], for any cats.Inject[A, Array[Byte]] instance (based on Schema.BYTES as well).\nAt Chatroulette, we use JSON-serialised data for which we derive a Schema.JSON based on Circe codecs and Avro schemas. Those interested in doing the same can leverage the Circe integration by adding the neutron-circe dependency.\nℹ️ When using schemas, prefer to create the producer(s) before the consumer(s) for fail-fast semantics.\nWe also need instances for Circe’s Decoder and Encoder, and for JsonSchema, which expects an Avro schema, used by Pulsar. Once you have it, you are an import away from having JSON schema support.\nimport cr.pulsar.schema.Schema\nimport cr.pulsar.schema.circe._\n\nimport io.circe.{Decoder, Encoder}\nimport io.circe.generic.semiauto._\n\ncase class Event(id: Long, name: String)\nobject Event {\n  implicit val jsonEncoder: Encoder[Event] = deriveEncoder\n  implicit val jsonDecoder: Decoder[Event] = deriveDecoder\n\n  implicit val jsonSchema: JsonSchema[Event] = JsonSchema.derive\n}\n\nval schema = Schema[Event] // summon an instance\nThe JsonSchema can be created directly using JsonSchema.derive[A], which uses avro4s under the hood. In fact, this is the recommended way but if you want to get something quickly up and running, you could also use auto-derivation.\nimport cr.pulsar.schema.Schema\nimport cr.pulsar.schema.circe.auto._\n\nimport io.circe.{Decoder, Encoder}\nimport io.circe.generic.semiauto._\n\ncase class Foo(tag: String)\nobject Foo {\n  implicit val jsonEncoder: Encoder[Foo] = deriveEncoder\n  implicit val jsonDecoder: Decoder[Foo] = deriveDecoder\n}\n\nval schema = Schema[Foo] // summon an instance\nNotice that avro4s is marked as Provided, meaning you need to explicitly add it to your classpath.","title":"Schema"},{"location":"/index.html#schema-compatibility-check-strategy","text":"Whenever using schemas, make sure you fully understand the different strategies, which only operate at the namespace level (e.g. see how integration tests are set up in the run.sh shell script).\nFor instance, when using the BACKWARD mode, a producer and consumer will fail to initialize if the schemas are incompatible, even if your custom JSON decoder can deserialize the previous model, the Pulsar broker doesn’t know about it. E.g. say we have this model in our new application.\ncase class Event(uuid: UUID, value: String)\nThe generated Avro schema will look as follows.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"cr.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  } ]\n}\nAnd later on, we introduce a breaking change in the model, adding a new mandatory field.\ncase class Event(uuid: UUID, value: String, code: Int)\nThis will be rejected at runtime, validated by Pulsar Schemas, when using the BACKWARD mode. The only changes allowed in this mode are:\nAdd optional fields Delete fields\nSee the generated Avro schema below.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"cr.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  }, {\n    \"name\" : \"code\",\n    \"type\" : \"int\"\n  } ]\n}\nInstead, we should make the new field optional with a default value for this to work.\ncase class Event(uuid: UUID, value: String, code: Option[Int] = None)\nThis is now accepted by Pulsar since any previous Event still not consumed from a Pulsar topic can still be processed by the new consumers expecting the new schema.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"cr.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  }, {\n    \"name\" : \"code\",\n    \"type\" : [ \"null\", \"int\" ],\n    \"default\" : null\n  } ]\n}\nSee the difference with the previous schema? This one has a default: null in addition to the extra null type.","title":"Schema Compatibility Check Strategy"}]}